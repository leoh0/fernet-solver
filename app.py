import base64
import uuid
import msgpack
import datetime
import logging
import sys

from cryptography import fernet

from six.moves import urllib

from flask import Flask, jsonify
from werkzeug.exceptions import BadRequest

_ISO8601_TIME_FORMAT_SUBSECOND = '%Y-%m-%dT%H:%M:%S.%f'
_ISO8601_TIME_FORMAT = '%Y-%m-%dT%H:%M:%S'


def isotime(at=None, subsecond=False):
    """Stringify time in ISO 8601 format."""
    # Python provides a similar instance method for datetime.datetime objects
    # called isoformat(). The format of the strings generated by isoformat()
    # have a couple of problems:
    # 1) The strings generated by isotime are used in tokens and other public
    #    APIs that we can't change without a deprecation period. The strings
    #    generated by isoformat are not the same format, so we can't just
    #    change to it.
    # 2) The strings generated by isoformat do not include the microseconds if
    #    the value happens to be 0. This will likely show up as random failures
    #    as parsers may be written to always expect microseconds, and it will
    #    parse correctly most of the time.

    if not at:
        at = datetime.datetime.utcnow()
    st = at.strftime(_ISO8601_TIME_FORMAT
                     if not subsecond else _ISO8601_TIME_FORMAT_SUBSECOND)
    tz = at.tzinfo.tzname(None) if at.tzinfo else 'UTC'
    st += ('Z' if tz == 'UTC' else tz)
    return st


def base64_encode(s):
    """Encode a URL-safe string.
    :type s: six.text_type
    :rtype: six.text_type
    """
    # urlsafe_b64encode() returns six.binary_type so need to convert to
    # six.text_type, might as well do it before stripping.
    return base64.urlsafe_b64encode(s).decode('utf-8').rstrip('=')


def construct_method_map_from_config():
    """Determine authentication method types for deployment.
    :returns: a dictionary containing the methods and their indexes
    """
    method_map = dict()
    method_index = 1
    for method in ["external", "password", "token", "oauth1"]:
        method_map[method_index] = method
        method_index = method_index * 2

    return method_map


def convert_integer_to_method_list(method_int):
    """Convert an integer to a list of methods.
    :param method_int: an integer representing methods
    :returns: a corresponding list of methods
    """
    # If the method_int is 0 then no methods were used so return an empty
    # method list
    if method_int == 0:
        return []

    method_map = construct_method_map_from_config()
    method_ints = []
    for k, _ in method_map.items():
        method_ints.append(k)
    method_ints.sort(reverse=True)

    confirmed_methods = []
    for m_int in method_ints:
        # (lbragstad): By dividing the method_int by each key in the
        # method_map, we know if the division results in an integer of 1, that
        # key was used in the construction of the total sum of the method_int.
        # In that case, we should confirm the key value and store it so we can
        # look it up later. Then we should take the remainder of what is
        # confirmed and the method_int and continue the process. In the end, we
        # should have a list of integers that correspond to indexes in our
        # method_map and we can reinflate the methods that the original
        # method_int represents.
        if (method_int / m_int) == 1:
            confirmed_methods.append(m_int)
            method_int = method_int - m_int

    methods = []
    for method in confirmed_methods:
        methods.append(method_map[method])

    return methods


class TokenFormatter(object):
    """Packs and unpacks payloads into tokens for transport."""
    def __init__(self, keys):
        self.keys = keys

    @property
    def crypto(self):
        """Return a cryptography instance.
        You can extend this class with a custom crypto @property to provide
        your own token encoding / decoding. For example, using a different
        cryptography library (e.g. ``python-keyczar``) or to meet arbitrary
        security requirements.
        This @property just needs to return an object that implements
        ``encrypt(plaintext)`` and ``decrypt(ciphertext)``.
        """
        return fernet.MultiFernet([fernet.Fernet(key) for key in self.keys])

    def unpack(self, token):
        """Unpack a token, and validate the payload.
        :type token: six.text_type
        :rtype: six.binary_type
        """
        # TODO(lbragstad): Restore padding on token before decoding it.
        # Initially in Kilo, Fernet tokens were returned to the user with
        # padding appended to the token. Later in Liberty this padding was
        # removed and restored in the Fernet provider. The following if
        # statement ensures that we can validate tokens with and without token
        # padding, in the event of an upgrade and the tokens that are issued
        # throughout the upgrade. Remove this if statement when Mitaka opens
        # for development and exclusively use the restore_padding() class
        # method.
        if token.endswith('%3D'):
            token = urllib.parse.unquote(token)
        else:
            token = TokenFormatter.restore_padding(token)

        try:
            return self.crypto.decrypt(token.encode('utf-8'))
        except fernet.InvalidToken:
            print('This is not a recognized Fernet token %s') % token
            raise

    @classmethod
    def restore_padding(cls, token):
        """Restore padding based on token size.
        :param token: token to restore padding on
        :type token: six.text_type
        :returns: token with correct padding
        """
        # Re-inflate the padding
        mod_returned = len(token) % 4
        if mod_returned:
            missing_padding = 4 - mod_returned
            token += '=' * missing_padding
        return token


class BasePayload(object):
    # each payload variant should have a unique version
    version = None

    @classmethod
    def create_arguments_apply(cls, **kwargs):
        """Check the arguments to see if they apply to this payload variant.
        :returns: True if the arguments indicate that this payload class is
                  needed for the token otherwise returns False.
        :rtype: bool
        """
        raise NotImplementedError()

    @classmethod
    def assemble(cls, user_id, methods, project_id, domain_id, expires_at,
                 audit_ids, trust_id, federated_info, access_token_id):
        """Assemble the payload of a token.
        :param user_id: identifier of the user in the token request
        :param methods: list of authentication methods used
        :param project_id: ID of the project to scope to
        :param domain_id: ID of the domain to scope to
        :param expires_at: datetime of the token's expiration
        :param audit_ids: list of the token's audit IDs
        :param trust_id: ID of the trust in effect
        :param federated_info: dictionary containing group IDs, the identity
                               provider ID, protocol ID, and federated domain
                               ID
        :param access_token_id: ID of the secret in OAuth1 authentication
        :returns: the payload of a token
        """
        raise NotImplementedError()

    @classmethod
    def disassemble(cls, payload):
        """Disassemble an unscoped payload into the component data.
        The tuple consists of::
            (user_id, methods, project_id, domain_id, expires_at_str,
             audit_ids, trust_id, federated_info, access_token_id)
        * ``methods`` are the auth methods.
        * federated_info is a dict contains the group IDs, the identity
          provider ID, the protocol ID, and the federated domain ID
        Fields will be set to None if they didn't apply to this payload type.
        :param payload: this variant of payload
        :returns: a tuple of the payloads component data
        """
        raise NotImplementedError()

    @classmethod
    def convert_uuid_hex_to_bytes(cls, uuid_string):
        """Compress UUID formatted strings to bytes.
        :param uuid_string: uuid string to compress to bytes
        :returns: a byte representation of the uuid
        """
        uuid_obj = uuid.UUID(uuid_string)
        return uuid_obj.bytes

    @classmethod
    def convert_uuid_bytes_to_hex(cls, uuid_byte_string):
        """Generate uuid.hex format based on byte string.
        :param uuid_byte_string: uuid string to generate from
        :returns: uuid hex formatted string
        """
        uuid_obj = uuid.UUID(bytes=uuid_byte_string)
        return uuid_obj.hex

    @classmethod
    def _convert_float_to_time_string(cls, time_float):
        """Convert a floating point timestamp to a string.
        :param time_float: integer representing timestamp
        :returns: a time formatted strings
        """
        time_object = datetime.datetime.utcfromtimestamp(time_float)
        return isotime(time_object, subsecond=True)

    @classmethod
    def attempt_convert_uuid_hex_to_bytes(cls, value):
        """Attempt to convert value to bytes or return value.
        :param value: value to attempt to convert to bytes
        :returns: tuple containing boolean indicating whether user_id was
                  stored as bytes and uuid value as bytes or the original value
        """
        try:
            return (True, cls.convert_uuid_hex_to_bytes(value))
        except ValueError:
            # this might not be a UUID, depending on the situation (i.e.
            # federation)
            return (False, value)


class UnscopedPayload(BasePayload):
    version = 0

    @classmethod
    def create_arguments_apply(cls, **kwargs):
        return True

    @classmethod
    def disassemble(cls, payload):
        (is_stored_as_bytes, user_id) = payload[0]
        if is_stored_as_bytes:
            user_id = cls.convert_uuid_bytes_to_hex(user_id)
        methods = convert_integer_to_method_list(payload[1])
        expires_at_str = cls._convert_float_to_time_string(payload[2])
        audit_ids = list(map(base64_encode, payload[3]))
        project_id = None
        domain_id = None
        trust_id = None
        federated_info = None
        access_token_id = None
        return (user_id, methods, project_id, domain_id, expires_at_str,
                audit_ids, trust_id, federated_info, access_token_id)


class DomainScopedPayload(BasePayload):
    version = 1

    @classmethod
    def create_arguments_apply(cls, **kwargs):
        return kwargs['domain_id']

    @classmethod
    def disassemble(cls, payload):
        (is_stored_as_bytes, user_id) = payload[0]
        if is_stored_as_bytes:
            user_id = cls.convert_uuid_bytes_to_hex(user_id)
        methods = convert_integer_to_method_list(payload[1])
        try:
            domain_id = cls.convert_uuid_bytes_to_hex(payload[2])
        except ValueError:
            # the default domain ID is configurable, and probably isn't a UUID
            # if payload[2] == CONF.identity.default_domain_id:
            #     domain_id = payload[2]
            # else:
            #     raise
            pass
        expires_at_str = cls._convert_float_to_time_string(payload[3])
        audit_ids = list(map(base64_encode, payload[4]))
        project_id = None
        trust_id = None
        federated_info = None
        access_token_id = None
        return (user_id, methods, project_id, domain_id, expires_at_str,
                audit_ids, trust_id, federated_info, access_token_id)


class ProjectScopedPayload(BasePayload):
    version = 2

    @classmethod
    def create_arguments_apply(cls, **kwargs):
        return kwargs['project_id']

    @classmethod
    def disassemble(cls, payload):
        (is_stored_as_bytes, user_id) = payload[0]
        if is_stored_as_bytes:
            user_id = cls.convert_uuid_bytes_to_hex(user_id)
        methods = convert_integer_to_method_list(payload[1])
        (is_stored_as_bytes, project_id) = payload[2]
        if is_stored_as_bytes:
            project_id = cls.convert_uuid_bytes_to_hex(project_id)
        expires_at_str = cls._convert_float_to_time_string(payload[3])
        audit_ids = list(map(base64_encode, payload[4]))
        domain_id = None
        trust_id = None
        federated_info = None
        access_token_id = None
        return (user_id, methods, project_id, domain_id, expires_at_str,
                audit_ids, trust_id, federated_info, access_token_id)


class TrustScopedPayload(BasePayload):
    version = 3

    @classmethod
    def create_arguments_apply(cls, **kwargs):
        return kwargs['trust_id']

    @classmethod
    def disassemble(cls, payload):
        (is_stored_as_bytes, user_id) = payload[0]
        if is_stored_as_bytes:
            user_id = cls.convert_uuid_bytes_to_hex(user_id)
        methods = convert_integer_to_method_list(payload[1])
        (is_stored_as_bytes, project_id) = payload[2]
        if is_stored_as_bytes:
            project_id = cls.convert_uuid_bytes_to_hex(project_id)
        expires_at_str = cls._convert_float_to_time_string(payload[3])
        audit_ids = list(map(base64_encode, payload[4]))
        trust_id = cls.convert_uuid_bytes_to_hex(payload[5])
        domain_id = None
        federated_info = None
        access_token_id = None
        return (user_id, methods, project_id, domain_id, expires_at_str,
                audit_ids, trust_id, federated_info, access_token_id)


class FederatedUnscopedPayload(BasePayload):
    version = 4

    @classmethod
    def create_arguments_apply(cls, **kwargs):
        return kwargs['federated_info']

    @classmethod
    def pack_group_id(cls, group_dict):
        return cls.attempt_convert_uuid_hex_to_bytes(group_dict['id'])

    @classmethod
    def unpack_group_id(cls, group_id_in_bytes):
        (is_stored_as_bytes, group_id) = group_id_in_bytes
        if is_stored_as_bytes:
            group_id = cls.convert_uuid_bytes_to_hex(group_id)
        return {'id': group_id}

    @classmethod
    def disassemble(cls, payload):
        (is_stored_as_bytes, user_id) = payload[0]
        if is_stored_as_bytes:
            user_id = cls.convert_uuid_bytes_to_hex(user_id)
        methods = convert_integer_to_method_list(payload[1])
        group_ids = list(map(cls.unpack_group_id, payload[2]))
        (is_stored_as_bytes, idp_id) = payload[3]
        if is_stored_as_bytes:
            idp_id = cls.convert_uuid_bytes_to_hex(idp_id)
        protocol_id = payload[4]
        expires_at_str = cls._convert_float_to_time_string(payload[5])
        audit_ids = list(map(base64_encode, payload[6]))
        federated_info = dict(group_ids=group_ids,
                              idp_id=idp_id,
                              protocol_id=protocol_id)
        project_id = None
        domain_id = None
        trust_id = None
        access_token_id = None
        return (user_id, methods, project_id, domain_id, expires_at_str,
                audit_ids, trust_id, federated_info, access_token_id)


class FederatedScopedPayload(FederatedUnscopedPayload):
    version = None

    @classmethod
    def disassemble(cls, payload):
        (is_stored_as_bytes, user_id) = payload[0]
        if is_stored_as_bytes:
            user_id = cls.convert_uuid_bytes_to_hex(user_id)
        methods = convert_integer_to_method_list(payload[1])
        (is_stored_as_bytes, scope_id) = payload[2]
        if is_stored_as_bytes:
            scope_id = cls.convert_uuid_bytes_to_hex(scope_id)
        project_id = (scope_id
                      if cls.version == FederatedProjectScopedPayload.version
                      else None)
        domain_id = (scope_id
                     if cls.version == FederatedDomainScopedPayload.version
                     else None)
        group_ids = list(map(cls.unpack_group_id, payload[3]))
        (is_stored_as_bytes, idp_id) = payload[4]
        if is_stored_as_bytes:
            idp_id = cls.convert_uuid_bytes_to_hex(idp_id)
        protocol_id = payload[5]
        expires_at_str = cls._convert_float_to_time_string(payload[6])
        audit_ids = list(map(base64_encode, payload[7]))
        federated_info = dict(idp_id=idp_id,
                              protocol_id=protocol_id,
                              group_ids=group_ids)
        trust_id = None
        access_token_id = None
        return (user_id, methods, project_id, domain_id, expires_at_str,
                audit_ids, trust_id, federated_info, access_token_id)


class FederatedProjectScopedPayload(FederatedScopedPayload):
    version = 5

    @classmethod
    def create_arguments_apply(cls, **kwargs):
        return kwargs['project_id'] and kwargs['federated_info']


class FederatedDomainScopedPayload(FederatedScopedPayload):
    version = 6

    @classmethod
    def create_arguments_apply(cls, **kwargs):
        return kwargs['domain_id'] and kwargs['federated_info']


class OauthScopedPayload(BasePayload):
    version = 7

    @classmethod
    def create_arguments_apply(cls, **kwargs):
        return kwargs['access_token_id']

    @classmethod
    def disassemble(cls, payload):
        (is_stored_as_bytes, user_id) = payload[0]
        if is_stored_as_bytes:
            user_id = cls.convert_uuid_bytes_to_hex(user_id)
        methods = convert_integer_to_method_list(payload[1])
        (is_stored_as_bytes, project_id) = payload[2]
        if is_stored_as_bytes:
            project_id = cls.convert_uuid_bytes_to_hex(project_id)
        (is_stored_as_bytes, access_token_id) = payload[3]
        if is_stored_as_bytes:
            access_token_id = cls.convert_uuid_bytes_to_hex(access_token_id)
        expires_at_str = cls._convert_float_to_time_string(payload[4])
        audit_ids = list(map(base64_encode, payload[5]))
        domain_id = None
        trust_id = None
        federated_info = None

        return (user_id, methods, project_id, domain_id, expires_at_str,
                audit_ids, trust_id, federated_info, access_token_id)


# For now, the order of the classes in the following list is important. This
# is because the way they test that the payload applies to them in
# the create_arguments_apply method requires that the previous ones rejected
# the payload arguments. For example, UnscopedPayload must be last since it's
# the catch-all after all the other payloads have been checked.
# TODO(blk-u): Clean up the create_arguments_apply methods so that they don't
# depend on the previous classes then these can be in any order.
PAYLOAD_CLASSES = [
    OauthScopedPayload,
    TrustScopedPayload,
    FederatedProjectScopedPayload,
    FederatedDomainScopedPayload,
    FederatedUnscopedPayload,
    ProjectScopedPayload,
    DomainScopedPayload,
    UnscopedPayload,
]

app = Flask(__name__)
app.logger.addHandler(logging.StreamHandler(sys.stdout))
app.logger.setLevel(logging.INFO)
LOG = app.logger


@app.route('/<path:path>')
def decyptor(path):
    # delete last '/' if exist
    if path.endswith('/'):
        path = path[:-1]

    paths = path.split('/')
    if len(paths) < 2:
        raise BadRequest('You need a token and at least 1+ keys.')

    token = ""
    keys = []
    for argument in paths:
        # fernet key size is always 44 = ((32 / 3) + 1) * 4
        if len(argument) == 44:
            keys.append(argument)
        elif len(argument) >= 180 and \
                len(argument) <= 240 and token == "":
            # set token
            token = argument
        else:
            # token is already setted but what is this argument?
            raise BadRequest("Dont recognized this argument: %s" % argument)

    try:
        formatter = TokenFormatter([x.encode('UTF8') for x in keys])

        serialized_payload = formatter.unpack(token)
        versioned_payload = msgpack.unpackb(serialized_payload)
        version, payload = versioned_payload[0], versioned_payload[1:]

        resp = {}

        for payload_class in PAYLOAD_CLASSES:
            if version == payload_class.version:
                (resp['user_id'], resp['methods'], resp['project_id'],
                 resp['domain_id'], resp['expires_at'], resp['audit_ids'],
                 resp['trust_id'], resp['federated_info'],
                 resp['access_token_id']) = (
                     payload_class.disassemble(payload))
                break

    except Exception:
        raise BadRequest('Decrypt failed')

    return jsonify(resp)


@app.route('/')
def hello_world():
    return 'OK'


if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=8080)
